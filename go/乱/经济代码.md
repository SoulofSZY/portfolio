## 写经济的代码

### 避免过度设计

**避免需求膨胀**

问题：频繁的需求变更不仅仅只是需求，还有不断重构的代码，不断延长的工期，不断增长的投入，以及越来越多的加班

技巧：识别最核心需求/迭代演进

管理好需求，是提高工作效率和软件效率最有效的路径

1. 从最终用户的角度看需求，识别什么是核心需求，什么是衍生需求，什么是无效需求。从而得到一个最小的子集，也就是现在必须满足的需求。
2. 迭代演进，兼容；上一版无法完成的事情放在下一版考虑
3. 迭代阶段,这时候需要考虑上一次没有完成的事情，以及变化促生的新需求,从中再次找到必须完成的需求
4. 迭代几轮后，会发现迭代过程中会有一些需求看似重要，随着版本迭代反而不重要了，甚至不需要解决，当然也会在迭代过程中衍生新需求或者加入新需求。

**避免过度设计**

对软件来说，过度设计的接口意味着更多的代码、更多的维护、更多的修修补补，未来也不会节省时间

1. 什么是必须做的
2. 什么是现在就必须做的

### 接口设计

1. 从真实问题开始，把大问题逐层分解为“相互独立（接口间互相不依赖），完全穷尽（所有情形）”的小问题、
2. 一个接口，应该只做一件事情。如果做不到，接口间的依赖关系要描述清楚

### 内存使用

c10k(同时处理 1 万个用户连接)/C10M(同时处理 1 千万个用户连接)

> 减少内存的使用，办法有且只有两个。第一个办法是减少实例的数量。第二个办法是减小实例的尺寸

**减少实例的数量**

1. 对于数量有限的对象，应该优先考虑使用枚举类型，比如交通标志，国家名称等等。其实，枚举类型就是一种常用的数据静态化的范例
2. 避免不必要的实例：Java 语言里，有一些历史遗留的接口设计问题，会无意中导致不必要的实例（String 原始数据类型）
3. 避免原始数据类滥用：拆装箱可能导致原始数据类对象陡增。
4. 单实例模式，从而减少多实例带来的不必要的开销

**减小实例尺寸**

1. 尽量减少独占空间
2. 尽量使用共享实例

**延迟分配减少实例数量**






