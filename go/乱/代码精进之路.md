## 代码精进之路

### 优秀的代码是经济、规范、安全的代码

1.  坚持使用最直观的编码方式，而不是追求代码简短，可以避免很多不必要的错误
2.  减少错误、节省时间，是现在选择编码方式的一个最基本的原则
3.  代码写得又快又好，是“经济”的；代码写得快，但是错误多，不是一个“经济”的行为
4.  代码跑得又快又好，是“经济”的；代码跑得快，但是安全问题突出，不是一个“经济”的行为
5.  代码写得精简易懂，是“经济”的；代码写得精简，但是没人看得懂，不是一个“经济”的行为

**好代码的一些标准**

1. 容易理解
2. 没有明显的安全问题
3. 能够满足最关键的需求 
4. 有充分的注释
5. 使用规范的命名
6. 经过充分的测试

**坏代码的一些情况**

1. 难以阅读的代码
2. 浪费大量计算机资源的代码
3. 代码风格混乱的代码
4. 复杂的，不直观的代码
5. 没有经过适当测试的代码

### 减少不必要的错误

1. 程序员：提高程序员的修养，是一个永不过时的课题。从别人的失败和自己的失败中学习、积累、提高，是一个程序员成长的必修课，优秀的代码源于对细节的热情和执着，如果能够找到哪怕仅仅是一个小问题的一个小小的改进办法，都有可能会给代码质量带来巨大的提升和改变
2. 编译器：编译器在代码质量方面，作为机器，恪尽职守，它可以帮助清除很多错误
3. 回归测试 （Regression Testing）：软件测试会尽可能地覆盖关键逻辑和负面清单，以确保关键功能能够正确执行，关键错误能够有效处理，测试代码还有一个关键用途就是做回归测试 。如果有代码变更，可以用回归测试来检查这样的代码变更有没有使代码变得更坏
4. 代码评审 （Code Review）：代码评审是一个有效的在软件研发过程中抵御人类缺陷的制度
5. 代码分析 （Code Analysis）：静态代码分析（Static Code Analysis）是通过对源代码的检查来发现潜在问题的一种软件质量保障方式。有很多静态代码分析工具可以帮助你检查代码缺陷，比如说商业软件
Coverity，以及开源软件 FindBugs

### 6个关键特质

1. 掌握一门编程语言
2. 解决现实问题：程序员的存在不是为了写代码，而是为了解决现实问题，实现现实价值
3. 发现关键问题：能够发现关键的问题，是一个好程序员和优秀程序员的分水岭，能够发现关键的问题，意味着我们可以从一个被动的做事情的程序员，升级为一个主动找事情的程序员
4. 沉静的前行者：优秀的程序员，一定是懂得妥协，懂得选择，一步一步把事情沉静地朝前推动的人
5. 可以依赖的伙伴：优秀的程序员是他人可以依赖的伙伴
6. 时间管理者：优秀的程序员是高效的时间管理者，要做只有你才能做的事情，要坚持做需要做的事情。

### 代码规范的价值

> 对代码有一种“洁癖”，那就是强调代码的规范化

**编码规范**指的是针对特定编程语言约定的一系列规则，通常包括文件组织、缩进、注释、声明、语句、空格、命名约定、编程实践、编程原则和最佳实践等

编码规范带来的潜在好处：学会了编码规范，并且严格地遵守它们，可以让工作更简单，更轻松，少犯错误

1. 规范的代码，可以降低代码出错的几率
2. 规范的代码，可以提高编码的效率：在代码制造的每一道关卡，规范执行得越早，问题解决得越早，整个流水线的效率也就越高
3. 规范的代码，降低软件维护的成本
4. 编程规范越使用越高效
SpotBugs

### 代码规范参考

#### 命名规范

**好处**

1. 为标识符提供附加的信息，赋予标识符现实意义。帮助理顺编码的逻辑，减少阅读和理解代码的工作量
2. 使代码审核变得更有效率，专注于更重要的问题，而不是争论语法和命名规范这类小细节，提高开发效率
3. 提高代码的清晰度、可读性以及美观程度
4. 避免不同产品之间的命名冲突

**常见命名方法**

1. 驼峰命名：CamelCase
2. 蛇形命名：snake_case,单词之间通过下划线“_”连接
3. 串式命名：kebab-case,单词之间通过连字符“-”连接
4. 匈牙利命名：标识符由一个或者多个小写字母开始，这些字母用来标识标识符的类型或者用途。标识符的剩余部分，可以采取其他形式的命名法，比如大驼峰命名法

**取名方法**

1. 要有准确意义：名字要能够准确、完整地表达出它代表的意义，可以见字知意，名副其实
2. 严格遵守命名规范：Java 倾向于使用驼峰命名法
3. 可读性优先
	1. 可读性强的名字优先于简短的名字，尽量使用完整的词汇
	2. 不要使用缩写、简写、缩略词，除非这些词语被广泛使用
	3. 不要使用太短的名字，比如一个字母，除非是广泛接受的特例（i/j/k/m/n 表示临时使用的整数，c/d/e 表示临时使用的字符）
	4. 避免含糊、混淆或者误导
 
**java中命名规范**

1. 不能以下划线或美元符号开始，也不能以下划线或美元符号结束
2. 类/接口：名字/名词短语，接口也可用形容词，大驼峰
3. 方法： 动词/动词短语 小驼峰
4. 参数名/成员变量/局部变量：小驼峰
5. 常量：蛇形命名，大写单词
6. 抽象类命名使用 Abstract 或 Base 开头 ； 异常类命名使用 Exception 结尾 ； 测试类命名以它要测试的类的名称开始，以 Test 结尾
7. 包名：名词，小写，单个单词
8. 枚举：类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开
9. 方法命名扩展：
	1. 获取单个对象的方法用 get 做前缀
	2. 获取多个对象的方法用 list 做前缀
	3. 获取统计值的方法用 count 做前缀
	4. 插入的方法用 save/insert 做前缀
	5. 删除的方法用 remove/delete 做前缀
	6. 修改的方法用 update 做前缀
10. 实体类命名扩展
	1. 数据对象： xxxDO ， xxx 即为数据表名
	2. 数据传输对象： xxxDTO ， xxx 为业务领域相关的名称
	3. 展示对象： xxxVO ， xxx 一般为网页名称

#### 代码排版
> 有效地使用空行、空格和缩进，简单的分割与对齐，可以使得代码的视觉效果甚至质量发生巨大的变化，理顺编码的思路，提高编码的效率。这是一个付出少、收获大，值得养成的好习惯


**大脑的角度**
其实整理代码，就是给代码分块。大脑接收信息是按照分块的模式进行的。一块就是一个可识别的信息，它被安放到短期记忆的“插槽”里。信息块的实际信息量是可变的，但是越简单、越具体的信息块越容易被记住和理解


**分块的原则**

1. 保持代码块的单一性，一个代码块只能有一个目标：代码块内所有的内容都是为了一个目标服务的，不能把无关的内容放在同一个代码块里。同一个代码块里语句的相互联系比与相邻代码块里的语句关系更为紧密
2. 注意代码块的完整性：代码块是一个完整的信息块。一个代码块要表达一个相对完整的意思，不能一个意思没说完就分块了，就像话说了半句一样
3. 代码块数量要适当：代码块过多，会让人觉得路径太长，逻辑复杂，不容易阅读理解。一个基础的代码块最好**不要超过 25 行**（通常显示屏小半个页面），否则就会有增加阅读理解的困难

**分块方法**
使用空白块

1. 同级别代码块靠左对齐
2. 同级别代码块空行分割
3. 下一级代码块向右缩进 四个空格（人性化）
4. 同行内代码块空格区隔
5. 一行一个行为
	1. 每行代码字符数的限制  根据实际情况：80-120个字符
	2. 如果一行不足以容纳一个表达式，就需要换行
	3. 在逗号后换行
	4. 在操作符前换行
	5. 高级别的换行优先
	6. 新的换行与上一行同级别表达式的开头对齐
	7. 如果上述规则导致代码混乱或者代码太靠右，使用 8 个空格作为缩进

### 注释
好处：来提高代码的可读性和可维护性的

问题：

1.	注释不需要运行，没有常规的办法测试，换句话说就是注释难以维护，需要随代码实现变更而变更。
2.	注释不能取代 精确的命名/清晰的代码结构/顺畅的逻辑
3.	注释的滥用 

注释类型：

1. 记录代码版权和授权 源文件开头 /* .. */ 星号注释
2. 生成用户档案	java doc /** .. */  类/接口方法
3. **解释源代码   //  静态方法/代码块/特殊变量


>一段代码不再需要，在测试完毕后，应该清理掉，而不是保留这个注释掉的代码块。

注释的原则：

1. 准确性
2. 必要性
3. 清晰性

总结

1. 类、类属性、类方法的注释必须使用 Javadoc 规范，使用/**内容*/格式
2. 静态方法/代码块/特殊变量   单行注释说明 //
3. 代码版权和授权 源文件开头  星号注释 /* .. */ 

### 声明
> 声明用来定义：类/方法/类变量/局部变量/常量。声明一般包括（限定/类型/名称）。

声明的实践方法：

1. 取好名字
2. 一行一个声明：方便变更和维护代码，错误更容易被发现
3. 局部变量使用时再声明： 方便阅读和记忆
4. 类属性集中声明： 类属性作用域较广，集中声明，方便查看
5. 声明时初始化： 针对简单类型，对于依赖较多/涉及计算/涉及资源等 	lazy-load更合适； 不过声明时初始化，可以防止初始化的遗漏以及	一些不必要的代码重复
6. 花括号： 针对类和方法声明（左括号不单独成行，紧跟语句尾	部，空	格分隔；右括号单独一行）
7. 小括号： 小括号紧靠标识符，不用空格分隔，方便识别标识符是不是一	个方法。
8. 搜索优化换行： 针对搜索引擎（SEO）/编辑器（vi）/系统工具（grep） 语义相关的词语，常见的搜索模式，尽可能放在一行 方便代码查找

### 异常

java异常的四要素：

1. 异常类命
2. 异常描叙
3. 异常堆栈
4. 异常转换

注意：

1. 异常状况的处理会让代码的效率变低
2. 标记清楚抛出的异常：
	1. 对于所有的可能抛出运行时异常，都要有清晰的描述，一个也不要错过
	2. 查看所有的调用方法的规范描述，确认抛出的异常要么已经处理，要么已经规范描述
3. 处理好捕获异常
	1. 异常类命，准确选择异常类
	2. 异常描叙， 清晰描叙异常信息
	3. 异常转换， 根据具体功能业务转换异常

实践

1. Java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避，而不应该通过 catch 来处理，比如：IndexOutOfBoundsException ， NullPointerException 等等
2.  catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理，不要对大段代码进行try-catch (可读性低下)
3.  捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容
4.  不能在 finally 块中使用 return ， finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句
5.  捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类


### 组织代码结构

代码文件头部结构/对象结构/类的内部结构/方法的代码结构/限定词的使用/空行的使用

**代码文件头部结构**

1. 版权和许可声明     		代码变更
2. 命名空间 package
3. 外部依赖 import

**对象结构**

1. 类的规范  ： 对于公共类，需要使用 since 标签
2. 类的声明
3. 类的属性和方法

**类的内部结构**

1. 类属性
2. 构造方法
3. 工厂方法
4. 其他方法

公有方法或保护方法 > 私有方法 >  getter / setter方法


**方法的代码结构**

1. 方法规范
2. 方法声明
3. 方法实现

典型的方法规范：

1. 方法简短介绍
2. 方法详细介绍（可选）
3. 方法参数描叙
4. 返回值描叙
5. 异常描叙
6. 创始版本 （和类同版本可不写）

**限定词**

推荐顺序：

1. public/private/protected (访问控制限定词)
2. abstract (抽象类/抽象方法)
3. static (静态类/方法/属性)
4. final (类/方法/属性)
5. transient (标记不能被序列化)
6. volatile (定义使用主内存的变量)
7. default (声明缺省的方法)
8. synchronized (声明同步)
9. native (声明本地方法)
10. strictfp (声明使用精度浮点运算)

**空行分隔代码块**

### 代码文件组织

解决几个问题：

1. 项目是干什么的？
2. 项目是怎么做的？
3. 项目该怎么使用？

问题1：

README文件维护和更新，存放在工程的根目录

一个软件项目开始时，这个问题的答案可以不是很丰满，但是，最基本的思想一定要有。随着软件的研发进程，它的描述可以越来越清晰。软件成型之前，这个问题必须干脆地解决掉，得到明确的答案

**软件可以拿来用吗?**

>所有的软件，都有归属，都受版权的保护

如果版权来源只有一个，而且源文件头部没有版权描述,可以在工程的根目录下在文件COPYRIGHT中记录

>能不能使用、怎么使用，是由软件的许可证确定的

许可证文件是 LICENSE，全部使用大写字母，放在软件工程项目的根目录下。当使用软件的时候，不能超越许可证约定的范围。 一个没有许可证的软件，是不能使用的，因为不知道许可的范围，也不知道应承担的义务。同样，如果一个软件的许可证不清晰，或者不了解，那么使用起来也会有很多法律问题

**软件是怎么实现的**

源代码存放在根目录下的src 目录下

**软件该怎么测试**

**软件怎么使用**

编写使用指南和代码示例是两个常用的办法。一份好的用户文档，应该让软件的用户快速入门，然后再逐步深入地了解整个软件的使用细节，以及潜在的问题。doc/


一个推荐的工程结构

	src/
		java/
			lang/
			io/
		javax/
			net/
				ssl/
	test/
		javax/
			net/
				ssl/
	doc/
	make/
	README
	COPYRIGHT
	LICENSE
	










